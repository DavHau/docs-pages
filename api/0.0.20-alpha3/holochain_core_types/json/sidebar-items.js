initSidebarItems({"fn":[["default_to_json","if all you want to do is implement the default behaviour then use #[derive(DefaultJson)] should only be used with From for JsonString i.e. when failure should be impossible so an expect is ok this is always true for serializable structs/enums standard boilerplate: impl From for JsonString {     fn from(v: MyStruct) -> Self {         default_to_json(v)     } }"],["default_try_from_json","if all you want to do is implement the default behaviour then use #[derive(DefaultJson)] standard boilerplate should include HolochainError as the Error: impl TryFrom for T {     type Error = HolochainError;     fn try_from(j: JsonString) -> HcResult {         default_try_from_json(j)     } }"]],"struct":[["JsonString","track json serialization with the rust type system! JsonString wraps a string containing JSON serialized data avoid accidental double-serialization or forgetting to serialize serialize any type consistently including hard-to-reach places like Option and Result JsonString must not itself be serialized/deserialized instead, implement and use the native `From` trait to move between types - moving to/from String, str, JsonString and JsonString simply (un)wraps it as raw JSON data - moving to/from any other type must offer a reliable serialization/deserialization strategy"],["JsonStringOption",""],["RawString","generic type to facilitate Jsonifying values directly JsonString simply wraps String and str as-is but will Jsonify RawString(\"foo\") as \"\"foo\"\" RawString must not implement Serialize because it should always convert to JsonString with from RawString can implement Deserialize because JsonString uses default serde to step down"]],"trait":[["DefaultJson",""],["JsonError","signifies type can be converted to JsonString in Err from some Result can't use std::error::Error for this because String has Error as a reserved future trait"]],"type":[["JsonResult",""]]});