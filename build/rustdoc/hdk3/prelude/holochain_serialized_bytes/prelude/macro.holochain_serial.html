<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `holochain_serial` macro in crate `hdk3`."><meta name="keywords" content="rust, rustlang, rust-lang, holochain_serial"><title>hdk3::prelude::holochain_serialized_bytes::prelude::holochain_serial - Rust</title><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled ><script src="../../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../../down-arrow.svg");}</style></head><body class="rustdoc macro"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../../hdk3/index.html'><div class='logo-container rust-logo'><img src='../../../../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class='location'><a href='../../../index.html'>hdk3</a>::<wbr><a href='../../index.html'>prelude</a>::<wbr><a href='../index.html'>holochain_serialized_bytes</a>::<wbr><a href='index.html'>prelude</a></p><script>window.sidebarCurrent = {name: 'holochain_serial', ty: 'macro', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../../../settings.html"><img src="../../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span></span><span class='in-band'>Macro <a href='../../../index.html'>hdk3</a>::<wbr><a href='../../index.html'>prelude</a>::<wbr><a href='../index.html'>holochain_serialized_bytes</a>::<wbr><a href='index.html'>prelude</a>::<wbr><a class="macro" href=''>holochain_serial</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><div class="example-wrap"><pre class="rust macro">
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">holochain_serial</span> {
    ( $( <span class="macro-nonterminal">$</span><span class="macro-nonterminal">t</span>:<span class="ident">ty</span> ),<span class="op">*</span> ) <span class="op">=</span><span class="op">&gt;</span> { ... };
}</pre></div>
</div><div class='docblock'><p>unidiomatic way to derive default trait implementations of TryFrom in/out of SerializedBytes</p>
<p>Two main reasons this was done rather than the normal Derive approach:</p>
<ul>
<li>Derive requires a separate crate</li>
<li>Derive doesn't allow for use of $crate to set unambiguous fully qualified paths to things</li>
</ul>
<p>Both of these limitations push dependency management downstream to consumer crates more than we
want to.
This implementation allows us to manage all dependencies explicitly right here in this crate.</p>
<p>There is a default implementation of SerializedBytes into and out of ()
this is the ONLY supported direct primitive round-trip, which maps to <code>nil</code> in messagepack
for all other primitives, wrap them in a new type or enum</p>
<p>e.g. do NOT do this:
<code>u32::try_from(serialized_bytes)?;</code></p>
<p>instead do this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">holochain_serialized_bytes</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SomeType</span>(<span class="ident">u32</span>);
<span class="macro">holochain_serial</span><span class="macro">!</span>(<span class="ident">SomeType</span>);
<span class="kw">let</span> <span class="ident">serialized_bytes</span> <span class="op">=</span> <span class="ident">SerializedBytes</span>::<span class="ident">try_from</span>(<span class="ident">SomeType</span>(<span class="number">50</span>)).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">some_type</span> <span class="op">=</span> <span class="ident">SomeType</span>::<span class="ident">try_from</span>(<span class="ident">serialized_bytes</span>).<span class="ident">unwrap</span>();</pre></div>
<p>put <code>SomeType</code> in a separate crate that can be shared by all producers and consumers of the
serialized bytes in a minimal way.
this is a bit more upfront work but it's the only way the compiler can check a type maps to
a specific serialization across different systems, crate versions, and refactors.</p>
<p>for example, say we changed <code>SomeType(u32)</code> to <code>SomeType(u64)</code> in the shared crate
with the new type the compiler can enforce roundtripping of bytes works everywhere <code>SomeType</code>
is used, provided all producers and consumers use the same version of the shared crate.
in the case where we have no <code>SomeType</code> and would use integers directly, there is no safety.
the system can't tell the difference between a type mismatch (e.g. you just wrote u32 in the
wrong spot in one of the systems) and a serialization mismatch (e.g. the serialized bytes
produced by some system were consumed by another system using a different version of the shared
crate or something).</p>
<p>Developers then have to manually mentally impose the meaning of primitives over the top of code
across different code-bases that are ostensibly separate projects.
This introduces the effect where you can't understand/refactor one component of the system
without understanding and refactoring all the other components in the same PR/QA step.</p>
<p>An explicit goal of SerializedBytes is to introduce stability of byte-level data interfaces
across systems, provided they share the same version of a shared types crate.
This means that that one component can implement a new version of the shared types and know
that it will be compatible with other components when they similarly upgrade AND other
components are safe to delay upgrading to the latest version of the shared crate until they are
ready to move. Essentially it allows for async development workflows around serialized data.</p>
<p>This is especially important for wasm as the wasm hosts and guests may not even be developed
by the same people/organisations, so there MUST be some compiler level guarantee that at least
the shared types within the same shared crate version have compatible serialization logic.</p>
<p>usually when working with primitives we are within a single system, i.e. a single compilation
context, a single set of dependencies, a single release/QA lifecycle
in this case, while we <em>could</em> wrap every single primitive in a new type for maximum compile
time safety it is often 'overkill' and we can eat some ambiguity for the sake of ergonomics and
minimising the number of parallel types/trait implementations.
in the case of parallel, decoupled, independently maintiained systems that rely on byte-level
canonical representation of things that will fail (e.g. cryptographically break or (de)allocate
memory incorrectly) if even one byte is wrong, the guide-rails provided by new types and enums
are worth the additional up-front effort of creating a few extra shared crates/types.</p>
<p>see the readme for more discussion around this</p>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../../../";window.currentCrate = "hdk3";</script><script src="../../../../main.js"></script><script defer src="../../../../search-index.js"></script></body></html>