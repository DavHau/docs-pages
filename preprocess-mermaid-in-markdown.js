#!/usr/bin/env node

import { mkdirSync, readdirSync, readFileSync, renameSync, unlinkSync, writeFileSync } from "node:fs";
import { basename, dirname, extname, resolve } from "path";
import chokidar from "chokidar";
import { run as runMermaid } from "@mermaid-js/mermaid-cli";
import recursiveReaddir from "recursive-readdir-files";

const args = process.argv.slice(2);
const namedArgs = args.filter((arg) => arg.startsWith('-'));
const paths = args
    .filter((arg) => !arg.startsWith('-'))
    .map((path) => path.split(':'));
const setupWatchers = namedArgs.find((arg) => arg == '--watch' || arg == '-w');
const embedSvg = namedArgs.find((arg) => arg == '--embed' || arg == '-e');

const escapeForRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

// Takes the file to process, the base paths of the source and destination, and
// the expected extension of the output, then runs the mermaid CLI on it to
// output a transformed Markdown file and zero or more image assets. Will fail
// silently on anything that doesn't end in `.md`, so that it can be used for
// both directory listings and the file watcher event handler.
async function preprocessMarkdownFile(fromFile, from, toMarkdown, handleSvgs) {
    const fileExt = extname(fromFile);
    if (fileExt != ".md") {
        return;
    }

    const toFile = fromFile.replace(new RegExp('^' + escapeForRegex(from)), toMarkdown);
    console.log("Processing ${fromFile} into ${toFile}...");

    mkdirSync(dirname(toFile), { recursive: true });
    await runMermaid(fromFile, toFile);

    let { toSvg, toSvgDocRoot, embed } = handleSvgs;
    if (handleSvgs) {
        // Now handle the SVG.
        // Look for the SVGs that match the pattern "<markdown-file-name>-<nn>.svg".
        const svgFileSearchPattern = escapeForRegex(basename(toFile, ".md")) + "-\\d+\\.svg";
        const svgFilesForMarkdownFile = readdirSync(dirname(toFile))
            .filter(file => basename(file).match(new RegExp("^" + svgFileSearchPattern + "$")))
            .map(file => dirname(toFile) + '/' + file);

        // No matter how we handle the SVGs, we need to modify the content of
        // the Markdown file. So load it now.
        let markdownContents = readFileSync(toFile, { encoding: 'utf8' });

        // Iterate over each found SVG, either embedding or moving it to the
        // specified SVG directory.
        for (let svgFile of svgFilesForMarkdownFile) {
            if (toSvg) {
                // Move the SVG to the specified location.
                const newSvgFileLocation = svgFile.replace(new RegExp("^" + escapeForRegex(toMarkdown)), toSvg);
                mkdirSync(dirname(newSvgFileLocation), { recursive: true });
                renameSync(svgFile, newSvgFileLocation);
                console.log(`Moved SVG file ${svgFile} to ${newSvgFileLocation}.`);
            } else if (embed) {
                // All SVG embeds generated by Mermaid should be on their own
                // line. So start/end the pattern with start/end markers.
                const svgImageUrlPattern = new RegExp("^\\!\\[[^\\]]+\]\\(\\./" + escapeForRegex(basename(svgFile)) + "\\)$", "gm");

                // Load the SVG file's contents.
                const svgContent = readFileSync(svgFile, { encoding: "utf8" });

                // We use `replace` rather than `replaceAll` because we know
                // that each SVG, being given an index according to where it was
                // found in the doc, will only appear once.
                markdownContents = markdownContents.replace(svgImageUrlPattern, svgContent);

                // We don't need the original SVG file anymore.
                unlinkSync(svgFile);

                console.log(`Embedded SVG file ${svgFile} in Markdown file and deleted it.`);
            }
        }

        // Now, if the SVG files have been moved rather than embedded, replace
        // the URLs in the generated Markdown file -- they'll always be expected
        // in the same path as the Markdown file, so just replace './' with the
        // asset path.
        if (toSvgDocRoot) {
            const svgFilesParentPath = dirname(toFile).replace(new RegExp("^" + escapeForRegex(toMarkdown)), toSvgDocRoot);
            const svgUrlsPattern = new RegExp("\\.(?=/" + svgFileSearchPattern + ")", "g");
            markdownContents = markdownContents.replaceAll(svgUrlsPattern, svgFilesParentPath);
            console.log(`Updated SVG file URLs in ${toFile}.`);
        }

        // We've done all the modifications to the Markdown file; save it now.
        writeFileSync(toFile, markdownContents);
        console.log(`Saved Markdown file ${toFile}.`);
    }
}

for (let [from, toMarkdown, toSvg = undefined, toSvgDocRoot = undefined] of paths) {
    from = resolve(from);
    toMarkdown = resolve(toMarkdown);
    let handleSvgs = {};

    if (embedSvg) {
        handleSvgs.embed = true;
        console.log("I'm going to embed generated SVGs in the Markdown files.");
    } else if (toSvg && toSvgDocRoot) {
        handleSvgs.toSvg = resolve(toSvg);
        handleSvgs.toSvgDocRoot = resolve(toSvgDocRoot);
        console.log(`I'm going to move generated SVGs to ${toSvg} and change their URLs in the Markdown files to point to ${toSvgDocRoot}/<subdir>.`);
    }

    if (setupWatchers) {
        // One watcher for each from:to:extension triplet; it's the easiest way to
        // preserve the right output path.
        console.log(`Watching ${from}...`);
        chokidar
            .watch(from)
            .on('add', file => preprocessMarkdownFile(file, from, toMarkdown, handleSvgs));
    } else {
        console.log(`Scanning ${from}...`);
        let matchedMarkdownFiles = await recursiveReaddir(from);
        matchedMarkdownFiles = matchedMarkdownFiles
            .filter(file => extname(file.name) == ".md")
            .map(file => resolve(file.path));
        for (let file of matchedMarkdownFiles) {
            preprocessMarkdownFile(file, from, toMarkdown, handleSvgs);
        }
    }
}

